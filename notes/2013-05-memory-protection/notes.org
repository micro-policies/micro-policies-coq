* Goal of these notes
- Trying to work out some of the details of a very different "label
  model" for the pico machine; one for memory protection
- This is inspired by Udit and Andre's experiments for their ASPLOS paper;
  and could maybe at some point help formalize what they are doing there
- This work would be orthogonal to the IFC "label model", and
  composing this with the IFC label model would be a different task
  that's not discussed here, and not necessary to get started

** Here are Udit's slides that are relevant here:
(taken from talks/internal/20130422_F2F_Penn/tmu_asplos2014.pdf)
- Spatial/Temporal Safety:
  - On each allocation, create a new ID (sequentially)
  - Assign the same ID to the pointer, and,
  - All the memory locations that are allocated
  - Upon de-allocation, change the ID on all the freed memory
    locations to some constant
- Spatial/Temporal Safey LM
  - Rule Computation:
    - Upon miss, install a rule that says that the ID on the pointer and
      memory location should be the one that missed
    - Put that rule into the TMU

* How does this work / how would this look like
** At the abstract level
(see main.pdf for a precise account of this)

The abstract machine for this "label model" would extend the
current pico abstract machine as follows:
- (a variant of) Swiss cheese memory model
  - a pointer is a pair of a frame (with base and bound) and an offset
  - the offset doesn't need to be inside bounds, and it can be negative
- pointers are distinguished from plain integers
  - 2 different kinds of values: pointers and integers
  - pointers are unforgeable!
- non-deterministic allocation primitive returning fresh pointers
- arbitrary (unchecked) pointer arithmetic is allowed
  - and it could happen with the normal arithmetic operations;
    i.e. adding a pointer to an integer returns a new pointer
    - seems that still requires a different opcode, so just 
      called this operation OffP (relative offsetting)
      - APT: Why does this require an extra opcode? Can't op be "polymorphic"?
      - CH: We can write it as "BinOp OffP" or even "BinOp +" if you
            like it more, but both the abstract semantics and the
            quasi-abstract semantics + rules have to treat this case
            very differently from the other binops -- so not
            parametrically polymorphic but ad-hoc polymorphic
            (overloaded). Is your point that since at the concrete
            level this will be implemented as an BinOp + (and all the
            magic will happen in the TMU), it should be called BinOp +
            even at the abstract levels? I would sympathize with that :)
  - there is no way to adding/subtracting two pointers
    - we want to prevent comparing pointers by subtraction
    - APT: subtraction could be permitted if pointers are both in same frame
    - CH: true; I've added this as a new instruction SubP; same
      discussion as for OffP applies here too
- pointers can get out bounds in either direction
  - offsets can be negative
- accessing out of bounds pointers is an error and stops the machine
- out of bounds pointers can become in bounds again,
  in which case accessing them should work fine
- out of bounds pointers can't all of a sudden start pointing to a
  different frame (quite obvious from the way we define things
  in the abstract machine)
- pointers can't be casted to integers and integers can't be casted to
  pointers (obvious from the definition)
- we can support manual memory reclaiming with free and prevent
  double/invalid frees and loads+stores after free

** At the quasi-abstract (tags + system calls + rules) level
(see main.pdf for a more abstract variant of this in which the rules
 and system calls are not extracted out of the semantics)

*** Tags

- We have three kinds of tags:
  - one for values (V)
  - another one for currently allocated memory locations (M)
  - another one for already freed memory locations (F)
    - we can assume that the whole memory starts out tagged F

T :=  V(Ty) | M(c,n,j,Ty) | F

- Both values and the payload of memory locations have a type (Ty)
  - the type of pointers includes the value of a monotonic counter at
    the time of allocation

Ty := I | P(c)

*** System calls
- Alloc, Free, and OffP are system calls
- Q: do we have any way of implementing system calls that keep state
  between invocations on the current concrete machine?
- assuming we find one, then here is the description of these calls
**** Alloc
- keeps a monotonic counter between invocations (because we have
  infinite precision integers we don't need to worry about overflows)
- increments this counter and reads its new value c
- pops a number j off the stack (fails otherwise)
- allocates a new frame of size j, obtaining a new int pointer n
  - either in the code, in which case it needs to keep track of
    previously allocated and freed frames (more state)
  - APT: One very simple scheme: don't reallocate freed frames; 
    always allocate fresh using a "next free location" pointer: 
    monotonic counter c can be same thing as "next free location"
    - CH: fine implementation for the concrete level,
          but the spec needs to be more abstract
    - CH: this implementation crucially depends on never reclaiming
          memory
    - CH: just noticed that my high-level spec is not
          abstract about this either (c+1)
  - or by executing a primitive privileged instruction of the
    concrete machine
- fills the new frame n...n+j-1 with zeroes tagged M(c,n,j,I)
[GONE:
- remembers the association c -> ALLOC(n,j) in an internal map
  - we need this association in order to know whether the frame was
    not already freed and what region of memory to invalidate on Free
  - an alternative to keeping a map on the side is to store this
    information with the memory's tag (i.e. replace c in M(c,Ty) with
    a triple: c, base, size)
    - the only (reasonable) assumptions are that:
      - always frame size > 0
      - freed pointers have to be in bounds]
  - CH2014: this seems like a stupid change in retrospect!  it polutes
    tags with crap that belongs in the allocator's internal data
    structures. It uses the tags in a bad way, causing larger
    memory consumption and general inefficiency. It makes for
    a very funny implementation of free (see below).
- pushes the atom n@P(c) to the stack and returns to user code

**** Free
- pops a pointer m@P(c) off the stack (otherwise it fails)
- loads the value stored in memory at location m and checks that
  it's tag is of the form M(c,n,j,_)
  - this fails if the memory location m is not yet allocated or
    already freed (i.e. stores atom tagged F)
  - this also fails if the atom stored at n is labeled (c',_,_,_) for
    some c != c'; which is an attempt to free an out-of-bounds pointer
- tags every element in the just freed frame (addresses n...n+j-1)
  with @F
  - the reason for this is that the pointer could have aliases and all
    those aliases have to be invalidated right away (i.e. before the
    allocator eventually reuses this memory)
- returns to user code

- Note: the allocator can now reuse this memory, but it will first tag
  it with a different counter value, so old pointers will never be
  able to access freed memory

**** Offp
- expects n@P(c) and m@I on top of the stack
- produces (n+m)@P(c) as the result without any additional checks
  - in particular there is no check that n+m is in bounds wrt c
- maybe this doesn't need to be a system call, but a plain
  addition; see discussion above

*** Rules
		Allow					Result
NOP		TRUE					-
OUT		TAG1=V(I)				TAG1
BINOP		TAG1=V(I) AND TAG2=V(I)			V(I)
PUSH		TRUE					V(I)
JUMP		TAG1=V(I)				-
BNZ		TAG1=V(I)				-
CALL		TAG1=V(I)				V(I)
RET		TAG2=V(I)				TAG1
LOAD		TAG1=V(P(c)) AND TAG2=M(c,_,_,T2)	V(T2)
STORE		TAG1=V(P(c)) AND TAG2=V(T2)
		             AND TAG3=M(c,n,j,T3)	M(c,n,j,T2)

- the pc tag is always @V(I), so I didn't write it in the table

- things like c and T2,T3 above are unification variables
  - I think this looks kind of cool, but if this is a problem to
    implement we can change to explicit testers (IS_V, IS_VI, IS_VP,
    IS_M) and deconstructors (GET_VPC, GET_MC, GET_BASE, GET_SIZE,
    GET_MT)

		Allow				Result
NOP		TRUE				-
OUT		IS_VI(TAG1)			TAG1
BINOP		IS_VI(TAG1) AND IS_VI(TAG2)	V(I)
PUSH		TRUE				V(I)
JUMP		IS_VI(TAG1)			-
BNZ		IS_VI(TAG1)			-
CALL		IS_VI(TAG1)			V(I)
RET		IS_VI(TAG2)			TAG1
LOAD		IS_VP(TAG1) AND IS_M(TAG2)
		AND GET_VPC(TAG1)=GET_MC(TAG2)	V(GET_MT(TAG2))
STORE		IS_VP(TAG1) AND IS_V(TAG2)
		AND IS_M(TAG3)
		AND GET_VPC(TAG1)=GET_MC(TAG3)	M(GET_MC(TAG1),
						  GET_BASE(TAG1),
                                                  GET_SIZE(TAG1),
						  GET_MT(TAG2))

- if OffP and SubP were instructions then they would have these rules

OFFP		IS_VP(TAG1) AND IS_VI(TAG2)	V(P(GET_VPC(TAG1)))
SUBP		IS_VP(TAG1) AND IS_VP(TAG2)
		AND GET_VPC(TAG1)=GET_VPC(TAG2)	V(P(GET_VPC(TAG1)))

- for this variant the syntax of tag and boolean expressions is as follows:

TE := TAG1 | TAG2 | TAG3 | TAGPC | V(TYPE) | M(NE1,NE2,NE3,TYPE)

BE := TRUE | IS_V(TE) | IS_VI(TE) | IS_VP(TE) | IS_M(TE) |
      NE1 = NE2 | BE1 AND BE2 | BE1 OR BE2

TYPE := I | P(NE) | GET_MT(TE)

NE := GET_MC(TE) | GET_VPC(TE) |  GET_BASE(TE) | GET_SIZE(TE)

- the forms TAGPC and BE1 OR BE2 are not used anywhere (OR would be
  used if we had overloading; in which case we would probably also
  need IF-THEN-ELSE in TE)

*** Previous discussion (rather obsolete now)
  - on malloc labeling contents and pointer the same
  - on each load and store compare ptr with cell
  - Q: what if pointers are stored in memory??
       what would that label mean?
  - A: pair of tags in memory
    - every memory cell has 2 tags:
      pointer tag (allocator returns such pointers,
                   pointer arithmetic preserves it)
      + frame tag (allocator instantiates memory with this)
    - things not in memory only one tag
  - BCP/APT: We should talk to Udit about what he has in mind here! 
  - APT: I asked Udit about that this evening. He hadn't 
    thought about the problem of having pointers in memory.

** At the concrete level
*** We need a way to do system calls
- Instruction that changes between user mode and kernel mode
- The first argument on the stack identifies the system call?
  (e.g. 0 = Alloc, 1 = Free)
*** We need a ReTag privileged instruction
Will be used by Alloc system call to tag the pointer it returns
*** We need a way to allocate things
- but at the concrete level the only property we need for the
  allocator is freshness, not protection
- as in C, the code can walk the whole memory, both allocated and
  not-yet-allocated
- this allocator can:
  - either be part of the concrete machine definition
    (i.e. implemented by an even lower level but abstracted away here)
  - or be implemented by the 
  - BCP/APT: Not clear that the former option makes sense
  - CH: why not?

* Pending questions/discussions/thinking:
** Concrete allocator: kernel vs user space
- how does writing an allocator interact with the 2 different address
  spaces idea; will we need 2 different allocators, one for
  "privileged memory" and another one for "user memory"?
  - seems that the built-in naive memory protection gets in the way of
    implementing this more interesting memory protection
  - BCP/APT: Kernel memory stays the same; user memory becomes swiss cheese
    (APT: maybe...)
  - CH: but for other label models (e.g. the IFC one) we will
    eventually need to allocate the tags; so the "privileged memory"
    will also need allocation
  - CH: anyway, for now I'm going to completely ignore that there is a
    kernel address space that might also need an allocator

** With the pair tagging mechanism for memory we are simulating additional per-frame tags
- Yes, but the low level machines have no frames, so we need to
  simulate it
- Q: Wouldn't it make sense to expose per-frame tags in the high-level
  abstract machine if exposing the TMU?
- That would be great, it might save us pair encodings later on

** We only need the c because memory can be explicitly freed and reclaimed
- otherwise n (base) and j (bounds) are enough information to check
  whether access is in bounds
- so if we don't care about having a Free system call, the base and
  the bounds are enough information on each (fat) pointer
  - that would be simpler, so shall we do it?

- Q: can we allow pointers to go out of bounds and return back into
  bounds in this new simpler setting?
  - yes, but with some extra trouble: need to detect them going out
    and remember how far they are from the base of the frame they
    used to point to (atomic group OBP(n,j,o))
  - but then, we can also do this for in-bounds pointers

- Q: To support this simple model, do we really need to tag memory
  differently than ordinary atoms? Isn't it enough to associate base
  and bounds to all pointers, and propagate and check that
  information with the TMU?
  - need to be careful here, the TMU can only look at the tags of
    operands, not at their values
  - the TMU won't have all the information it needs to decide if
    a Load or a Store should be allowed. It won't have the actual
    value of the pointer, only the base and the bounds!
  - lifting the value of the pointer to its tag means that the
    TMU will be performing the same operations at the ALU
    - except that it can't do that for offsetting, because integers
      are not lifted this way
    - also lifting integers would be equivalent to passing all values
      into the TMU, but then its functioning as a cache will be very
      limited
- A (short): This won't work!
  - Is this the reason why the SAFE machine has a separate pointer
    unit?

- Q: In this simpler model, at the quasi-quasi-abstract level, do we
  even need to distinguish pointers from integers?
- A: Yes, see below.

- Q: In this simpler model, at the quasi-quasi-abstract level, do we
  prevent a pointer from moving to another valid frame and then
  changing it?
  - we turn P(c) into P(n) as proposed by Andrew; so yes, we still
    need to distinguish pointers from integers
