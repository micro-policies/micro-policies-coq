
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar I {{tex \iota }} ::=      {{com instruction memory}}

metavar M {{tex \mu }} ::=      {{com abstract memory (maps frame pointers to frames)}}

metavar fp {{tex \mathit{fp} }} ::=      {{com frame pointer}}

metavar c {{tex \mathitbf{c} }} ::= {{com monotonic counter}}

metavar cM {{tex \boldsymbol{\mu} }} ::= {{com concrete memory}}

indexvar i , j ::=  {{com indices}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

%M {{tex \mu}} :: 'M_' ::=            {{com Memory }}
%   | { fp1 |-> frame1 ... fpj |-> framej } :: :: Mem {{ com map from frame pointers to frames }}
%   | M + { fp |-> frame } :: :: MemPlus {{ com extend a memory with a fresh frame }} 

vs :: 'vs_' ::=
  | v1 , .. , vj :: :: Vs
  | vs [ i := v ] :: :: Vupdate
%  | zeroes j :: :: Zeroes {{tex 0, ,0}}

frame :: 'fr_' ::=            {{com Memory frame }}
%   | CFR [ instr1 , .. , instrj ] :: :: CFrame {{ com Code frame }}
   | DFR [ vs ] :: :: FData {{com Data frame}}
%   | DFR [ v1 .. vi , v , vi' .. vj' ] :: S ::Stuff
   | FREE             :: :: FFree {{com Free data frame}}

p :: 'p_' ::=                         {{com Pointers}}
  | < fp , n >                :: :: DMPnt {{com frame pointer and offset}} {{tex \left< [[fp]] , [[n]] \right>}}

n, m, k, pc :: 'n_' ::= {{com Integers}}
  | 0                       :: :: Zzro
  | 1                       :: :: Zone
  | n1 + n2                 :: :: ZPlus
  | n1 - n2                 :: :: ZMinus
  | n1 o n2                 :: :: ZBinOp
  | ( n1 = n2 ) ? n3 : n4   :: :: ZIf
  | - n                     :: :: ZNeg
  | j                       :: S :: ZIndex
  | c                       :: S :: ZCounter
  | ( n )                   :: S :: ZParen

u, v :: 'v_' ::= {{com Values}}
  | n :: :: VInt
  | p :: :: VPtr 
  | ( v ) :: :: VParen

instr :: 'instr_' ::=                              {{com Instructions}}
  | Nop                     :: :: iNop
  | Push n                  :: :: iPush    {{com push constant integer}}
%  | Pop                     :: :: iPop
%  | Dup                     :: :: iDup
  | BinOp o                 :: :: iBinOp   {{com binary op, returning integer}}
  | Jump                    :: :: iJump
  | Bnz n                   :: :: iBnz     {{com conditional relative jump}}
  | Call                    :: :: iBCall
  | Ret                     :: :: iBRet
  | Load                    :: :: iLoad    
  | Store                   :: :: iStore
  | Output                  :: :: iOutput  {{com output top of stack}}
%  | Halt                    :: :: iHalt
  | Alloc                   :: :: iAlloc   {{com non-deterministic allocation of a memory frame }}
  | Free                    :: :: iFree {{com deallocation}}
  | OffP                    :: :: iOffP {{com relative pointer offsetting}}
  | SubP                    :: :: iSubP {{com pointer subtraction (comparison)}}

e :: 'e_' ::=                              {{com Events}}
  | esilent                 :: :: esilent {{com no event }}
  | n                       :: :: intE  {{com observable value event }}
  | ( e )                   :: S :: eParen   

opcode :: 'opcode_' ::=                              {{com Opcodes}}
  | nop                     :: :: oNop
  | push                    :: :: oPush    {{com push constant integer}}
%  | pop                     :: :: oPop
%  | dup                     :: :: oDup
  | binop                   :: :: oBinOp   {{com binary op, returning integer}}
  | jump                    :: :: oJump
  | bnz                     :: :: oBNZ     {{com conditional relative jump}}
  | call                    :: :: oBCall
  | ret                     :: :: oBRet
  | load                    :: :: oLoad    
  | store                   :: :: oStore
  | out                  :: :: oOutput  {{com output the top of the stack, tainted with pc}}
%  | halt                    :: :: oHalt

S {{tex \sigma }} :: 'S_' ::=                     {{com Stack}}
  | Smty                    :: :: Smty     {{com empty stack}}
  | v ; S                   :: :: Sdcons   {{com stack value cons}}
  | pc ;; S                 :: :: Srcons   {{com stack frame marker cons (with
                                                 return pc and protecting label)}}
  % | S1 $ S2                 :: ::   Sappend  {{com stack append}}
  | [ S ]                   :: :: SParen
  % | [ a1 .. aj ]            :: :: SElems

% Slightly less abstract machine

T :: 'T_' ::= 
  | TV ( Ty ) :: :: TVal {{tex \mathsf{V}\left([[Ty]]\right)}}
  | TM ( n , m , k , Ty ) :: :: TMem {{tex \mathsf{M}\left([[n]],[[m]],[[k]],[[Ty]]\right)}}
                                     {{com allocated frame}}
  | TF :: :: TFree {{tex \mathsf{F} }} {{com already freed frame}}

Ty :: 'Ty_' ::=
  | Int :: :: TyI {{tex \mathsf{Int} }}
  | Ptr ( n ) :: :: TyP {{tex \mathsf{Ptr}\left([[n]]\right)}}

aa {{tex \mathitbf{a} }}, apc {{tex \mathitbf{pc} }} :: 'aa_' ::=  {{com Atoms}}
  | n @ T                   :: :: aAtom {{com tagged integer}}
  | aa + n                  :: :: aANext {{com increment offset part of code pointer }}
  | ( aa )                  :: S :: aAParen

aS {{tex \boldsymbol{\sigma} }} :: 'aS_' ::=  {{com Slightly less abstract stack}}
  | aSmty                    :: :: aSmty     {{com empty stack}}
  | aa ; aS                  :: :: aSdcons   {{com stack atom cons}}
  | apc ;; aS     :: :: aSrcons   {{com stack frame marker cons}}
  | [ aS ]                   :: :: cSParen


formula :: formula_ ::=  
 | judgement                :: :: judgement
 | I ( apc ) = instr         :: :: apc_lookup
 | I ( pc ) = instr         :: :: pc_lookup  {{com instruction lookup (fails if pc not a code pointer)}}
 | I ( n ) = instr          :: :: instr_lookup  {{com instruction lookup }}
 | M ( fp ) = frame         :: :: read_frame
 | M [ fp := frame ] = M'   :: :: update_frame
 | fp freshfor M            :: :: fpfreshfor  {{com [[fp]] fresh for [[M]]}}
 | n > m                    :: :: gtnat

 | n freshfor ( cM , j )    :: :: freshforcm
 | aM [ n := f ] = aM'      :: :: aMupd
 | cM [ n := aa | m in 0 to k ] = cM' :: :: cMupdMulti
 | cM [ n := aa ] = cM'     :: :: cMupd
 | aM ( c ) = f             :: :: aMlookup
 | cM ( n ) = aa            :: :: cMlookup

 | n1 <> n2                 :: :: not_eq_int
 | n1 = n2                  :: :: eq_int
 | M1 = M2                  :: :: eq_mem
 % | p1 <> p2                 :: :: not_eq_pntr
 % | p1 = p2                  :: :: eq_pntr
 | a1 = a2                  :: :: eq_atm
 | RHS1 = RHS2              :: :: rhs_eq
 | S1 = S2                  :: :: stack_eq
 | n1 = .. = nj = n         :: :: ints_eq

 | n1 <= n2 < n3            :: :: in_bounds
 | vs1 = vs2                :: :: vs_eq

 | aa1 = aa2                  :: :: aeq_atm

 | F ( n ) = instr         :: :: instr_lookup_priv  {{com fault handler instruction lookup }}
 | read cM p = ca             :: :: cread          {{com read from data memory }}
 | store cM p ca = cM'         :: :: cstore         {{com memory store of atom }}
 | read C p = ca             :: :: load_priv          {{com read from cache }}
 | store C p ca = C'         :: :: store_priv         {{com cache write of atom }}
 | C1 ~ C2                  :: :: cache_eq         {{com cache hit (equality of caches) }}
 
 | ki1 ~/~ ki2 ~ ki3        :: :: cache_neq         {{com cache input miss and update }}

 % | v1 = .. = vj = v         :: :: vals_eq
 | formula1 ==> formula2    :: :: implication
 | formula1 quad formula2   :: :: savingspace
 | formula1 and formula2      :: :: conjunction
 | ( formula )                :: S :: parens_formula
 | variable := formula            :: :: let_formula
 


terminals :: 'terminals_' ::=
  | ==>                 :: :: eval       {{tex \Longrightarrow }}
  | quad                :: :: savespace  {{tex \qquad }}
  | \/                  :: :: join       {{tex \mathord{\vee} }}
  | |_|                 :: :: ljoin      {{tex \mathord{\sqcup} }}
  | <>                  :: :: noteq      {{tex \neq }}
  | @                   :: :: atlabel    {{tex \mathord{\scriptstyle @} }}
  | ;;                  :: :: semisemi   {{tex \mathord{;\!;} }}
  | +                   :: :: plus       {{tex \mathord{+} }}
  | ++                  :: :: dplus      {{tex {\scriptstyle \mathord{+\!+} } }}
  | mpty_i              :: :: mpty_i     {{tex \epsilon}}
  | +1                  :: :: plusplus   {{tex {\scriptstyle \mathord{+\!+} } }}
  | |->                 :: :: mapsto     {{tex {\scriptstyle \mathord{\mapsto} } }}
  | forall              :: :: forall     {{tex \forall }}
  | exists              :: :: exists     {{tex \exists }}
  | <=                  :: :: le         {{tex \le }}
  | Smty                :: :: Smty       {{tex \text{\sf mty} }}
  | bot                 :: :: bot        {{tex \bot }}
  | <|                  :: :: lcp        {{tex \langle }}
  | |>                  :: :: rcp        {{tex \rangle }}

  | :=                  :: :: let        {{tex :=}}

  | pi_1                :: :: proj1      {{tex \pi_1}}
  | pi_2                :: :: proj2      {{tex \pi_2}}
  | and                 :: :: and        {{tex \wedge}}

  | Call                :: :: Call       {{tex \text{\sf Call} }} 
  | Output              :: :: Output     {{tex \text{\sf Output} }}
  | Load                :: :: Load       {{tex \text{\sf Load} }} 
  | Store               :: :: Store      {{tex \text{\sf Store} }} 
  | Nop                 :: :: Nop        {{tex \text{\sf Nop} }}
  | Push                :: :: Push       {{tex \text{\sf Push} }} 
  | Pop                 :: :: Pop        {{tex \text{\sf Pop} }} 
  | Dup                 :: :: Dup        {{tex \text{\sf Dup} }} 
  | BinOp               :: :: BinOp      {{tex \text{\sf BinOp} }}
  | Jump                :: :: Jump       {{tex \text{\sf Jump} }} 
  | Bnz                 :: :: Bnz        {{tex \text{\sf Bnz} }} 
  | Ret                 :: :: Ret        {{tex \text{\sf Ret} }} 
%  | Halt                :: :: Halt       {{tex \text{\sf Halt} }} 

  | esilent             :: :: eE0        {{tex \tau }} 

  | TRUE                :: :: e_true     {{tex \texttt{TRUE} }}
  | AND                 :: :: e_and      {{tex \mathtt{AND} }}
  | OR                  :: :: e_or       {{tex \mathtt{OR}  }}

  | cesilent             :: :: ceE0       {{tex \tau }} 
  | upriv               :: :: upriv     {{tex \text{\sf u} }} 
  | kpriv               :: :: kpriv      {{tex \text{\sf k} }} 
  | Tbot                :: :: Tbot        {{tex \mathtt{T}_{\bot} }}
  | ~                   :: :: match      {{tex = }}
  | ~/~                 :: :: dmatch     {{tex \not= }}

defns
AbstractHighLevelSmallStep :: '' ::=

  defn 
  M1 , I1 , S1 , pc1 -- e -> M2 , I2 , S2 , pc2  :: :: ahstep :: '' 
  {{tex  [[M1]], [[S1]], [[pc1]] \xrightarrow{[[e]]}
         [[M2]], [[S2]], [[pc2]] }} by

     I(n) = Nop
     -------------------------------------------------------- :: Step_Nop
     M, I, S, n -- esilent -> M, I, S, n+1

     I(n) = Output
     -------------------------------------------------------- :: Step_Output
     M, I, [m; S], n  -- m ->  M, I, S, n+1

     % BinOp just takes numbers; but we also want to offset pointers
     I(n) = BinOp o
    --------------------------------------------------------- :: Step_BinOp
     M, I, [n1; n2; S], n -- esilent -> M, I, [n1 o n2; S], n+1

     I(n) = Push m
     -------------------------------------------------------- :: Step_Push
     M, I, S, n -- esilent -> M, I, [m; S], n+1

     I(n) = Jump
      -------------------------------------------------------- :: Step_Jump
     M, I, [m; S], n -- esilent -> M, I, S, m
    
     I(n) = Bnz k
     n' = n + (m = 0)? 1 : k  
     -------------------------------------------------------- :: Step_Bnz
     M, I, [m; S], n -- esilent -> M, I, S, n'
    
     I(n) = Call
     -------------------------------------------------------- :: Step_Call
     M, I, [ m ; v ; S], n -- esilent -> M, I, [v; n+1 ;; S], m

     I(n) = Ret
     -------------------------------------------------------- :: Step_Ret
     M, I, [v ; n' ;; S], n -- esilent -> M, I, [v ; S], n'

     I(pc) = Alloc   quad    fp freshfor M    quad   M[fp := DFR[n0,..,nj-1]] = M'  quad   n0 = .. = nj-1 = 0
     -------------------------------------------------------- :: Step_Alloc
     M, I, [j; S], pc -- esilent -> M', I, [<fp,0>; S], pc+1

     I(pc) = Load   quad   M(fp) = DFR[v0,..,vj-1]   quad   0 <= i < j
     -------------------------------------------------------- :: Step_Load
     M, I, [<fp,i>; S], pc -- esilent -> M, I, [vi; S], pc+1

     %Ott is too dumb to handle this:
     %M[fp := DFR[v1, .., vi-1, v, vi+1, .., vj]] = M'
     I(pc) = Store   quad  M(fp) = DFR[vs]   quad   vs = v0,..,vj-1   quad   0 <= i < j
     M[fp := DFR[ vs[i:=v] ] ] = M'
     -------------------------------------------------------- :: Step_Store
     M, I, [<fp,i>; v; S], pc -- esilent -> M', I, S, pc+1

     I(pc) = Free   quad   M(fp) = DFR[vs]   quad   M[fp := FREE] = M'
     -------------------------------------------------------- :: Step_Free
     M, I, [<fp,i>; S], pc -- esilent -> M', I, S, pc+1

     I(pc) = OffP
     -------------------------------------------------------- :: Step_OffP
     M, I, [<fp,i>; m; S], pc -- esilent -> M', I, [<fp,i+m>; S], pc+1

     I(pc) = SubP
     -------------------------------------------------------- :: Step_SubP
     M, I, [<fp,i>; <fp,j>; S], pc -- esilent -> M', I, [i-j; S], pc+1

defns
AbstractSlightlyLessHighLevelSmallStep :: '' ::=

  defn 
  n1 , cM1 , I1 , aS1 , apc1 -- e -> n2 , cM2 , I2 , aS2 , apc2  :: :: aslhstep :: 'X' 
  {{tex  [[n1]], [[cM1]], [[aS1]], [[apc1]] \xrightarrow{[[e]]}
         [[n2]], [[cM2]], [[aS2]], [[apc2]] }} by

     I(apc) = Nop
     -------------------------------------------------------- :: Step_Nop
     c, cM, I, aS, apc -- esilent -> c, cM, I, aS, apc+1

     I(apc) = Output
     -------------------------------------------------------- :: Step_Output
     c, cM, I, [m@TV(Int); aS], apc  -- m ->  c, cM, I, aS, apc+1

     % BinOp just takes numbers; but we also want to offset pointers
     I(apc) = BinOp o
    --------------------------------------------------------- :: Step_BinOp
     c, cM, I, [n1@TV(Int); n2@TV(Int); aS], apc -- esilent -> c, cM, I, [(n1 o n2)@TV(Int); aS], apc+1

     I(apc) = Push m
     -------------------------------------------------------- :: Step_Push
     c, cM, I, aS, apc -- esilent -> c, cM, I, [m@TV(Int); aS], apc+1

     I(apc) = Jump
      -------------------------------------------------------- :: Step_Jump
     c, cM, I, [m@TV(Int); aS], apc -- esilent -> c, cM, I, aS, m@TV(Int)
    
     I(apc) = Bnz k
     apc' = apc + (m = 0)? 1 : k
     -------------------------------------------------------- :: Step_Bnz
     c, cM, I, [m@TV(Int); aS], apc -- esilent -> c, cM, I, aS, apc'
    
     I(apc) = Call
     -------------------------------------------------------- :: Step_Call
     c, cM, I, [ apc' ; aa ; aS], apc -- esilent -> c, cM, I, [aa; apc+1 ;; aS], apc'

     I(apc) = Ret
     -------------------------------------------------------- :: Step_Ret
     c, cM, I, [aa ; apc' ;; aS], apc -- esilent -> c, cM, I, [aa ; aS], apc'

     I(apc) = Alloc   quad    j > 0    quad    n freshfor (cM,j)
     cM [ n+i := 0@TM(c+1,n,j,Int) | i in 0 to j-1 ] = cM'
     -------------------------------------------------------- :: Step_Alloc
     c, cM, I, [j@TV(Int); aS], apc -- esilent -> c+1, cM', I, [n@TV(Ptr(c+1)); aS], apc+1

     I(apc) = Load   quad   cM(m)=k@TM(c,n,j,Ty)
     -------------------------------------------------------- :: Step_Load
     c, cM, I, [m@TV(Ptr(c)); aS], apc -- esilent -> c, cM, I, [k@TV(Ty); aS], apc+1

     I(apc) = Store   quad   cM(m)=k'@TM(c,n,j,Ty')   quad  cM[m := k@TM(c,n,j,Ty)] = cM'
     -------------------------------------------------------- :: Step_Store
     c, cM, I, [m@TV(Ptr(c)); k@TV(Ty); aS], apc -- esilent -> c, cM', I, aS, apc+1

     I(apc) = Free   quad   cM(m)=k@TM(c,n,j,Ty) quad  cM [ n+i := 0@TF | i in 0 to j-1 ] = cM'
     -------------------------------------------------------- :: Step_Free
     c, cM, I, [m@TV(Ptr(c)); aS], apc -- esilent -> c, cM', I, aS, apc+1

     I(apc) = OffP
     -------------------------------------------------------- :: Step_OffP
     c, cM, I, [n@TV(Ptr(c)); m@TV(Int); aS], apc -- esilent -> c, cM', I, [(n+m)@TV(Ptr(c)); aS], apc+1

     I(apc) = SubP
     -------------------------------------------------------- :: Step_SubP
     c, cM, I, [n@TV(Ptr(c)); m@TV(Ptr(c)); aS], apc -- esilent -> c, cM', I, [(n-m)@TV(Int); aS], apc+1
