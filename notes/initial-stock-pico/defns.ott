
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

metavar r, ra ::= {{com register number (e.g. 0..31)}}

metavar D ::= {{com decoding (partial function)}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

o {{tex \mathord{\circ} }} :: 'o_' ::= {{com binary ops}}
  | + :: :: OPlus
  | - :: :: OMinus

M :: 'M_' ::= {{com memory}}
  | M [ w <- a ] :: M :: mem_update {{com memory update}}
  | M [ w <- a ; priv ] :: M :: mem_updatex {{com memory update}}
  | M [ <- ki ]  :: M :: mem_rule_store {{com store rule inputs somewhere in KERNEL memory}}

R :: 'R_' ::= {{com register file}}
  | R [ r <- a ; tpc ] :: M :: reg_update {{com register update}}
  | R [ r <- a ; priv ] :: M :: reg_updatex {{com register update}}

K :: 'K_' ::= {{com rule cache}}
  | K U { k } :: M :: cache_add {{tex [[K]] \cup \{ [[k]] \} }}{{com adding rule [[k]] to cache [[K]]}}

w, wi {{tex w_i}}, n, pc, sp, t, tpc {{tex t_\mathit{pc} }}, ti {{tex t_i}}, tr {{tex t_r}}, trpc {{tex t_\mathit{rpc} }} :: 'w_' ::= {{com Words (Integers)}}
  | 0          :: :: Zzero
  | 1          :: :: Zone
  | n1 o n2    :: :: ZBinOp  {{com binop on ints returns int}}
  | KERNEL     :: :: TKernel {{com kernel tag}}
  | ANY        :: :: TAny {{com wildcard tag (used in ground rules) }}
  | ( n1 = n2 ) ? n3 : n4  :: M :: ZIf
  | _          :: M :: Tirrev {{tex \_}}{{com irrelevant tag}}
  | X          :: M :: TX {{com some magic constant}}
  | ( w )      :: S :: ZParen

a, b, epc  :: 'a_' ::= {{com Atoms}}
  | w @ t    :: :: Atom {{com atom = tagged word }}
  | M ( w )  :: M :: mem_lookup  {{com memory lookup (partial function)}}
  | M ( w ; priv )  :: M :: mem_lookupx  {{com memory lookup (partial function)}}
  | R ( r ; tpc ) :: M :: reg_lookup  {{com register lookup (partial function)}}
  | R ( r ; priv ) :: M :: reg_lookupx  {{com register lookup (partial function)}}
  | ( a )    :: S :: AParen

i :: 'i_' ::=  {{com Instructions}}
  | Nop              :: :: INop    {{com do nothing (used for KENTRY)
\ch{Replaced by Mov in Coq; we might need Nop back
                            when adding back system calls} }}
  | Const n r        :: :: IConst  {{com load constant}}
  | BinOp o r1 r2 r  :: :: IBinOp  {{com binary arithmetic operation}}
  | Load r1 r        :: :: ILoad   {{com memory load (from the address in [[r1]] to [[r2]])}}
  | Store r1 r2      :: :: IStore  {{com memory store (word in [[r2]] at address in [[r1]])}}
  | Jump r           :: :: IJump   {{com indirect jump (absolute)}}
  | Bnz r n          :: :: IBnz    {{com conditional branch non-zero (relative)}}
  | JAL r1           :: :: IJAL    {{com jump and link (call subroutine; absolute)}}
  | WriteEpc r       :: :: IWriteEpc {{com write to $[[epc]]$ special register (privileged)}}
  | JumpEpc          :: :: IJumpEpc {{com return from the kernel (privileged)}}
  | AddRule          :: :: IAddRule {{com add rule to TMU cache (privileged)}}
  | GetTag r1 r      :: :: IGetTag  {{com make the tag of [[r1]] the payload of [[r]] (privileged)}}
  | PutTag r1 r2 r   :: :: IPutTag  {{com set [[r]] to atom with payload of [[r1]]
                                          and payload of [[r2]] as tag (privileged)}}
  | D ( w )          :: M :: IDecode  {{com decoding (partial function)}}

op :: 'op_' ::=  {{com Opcodes}}
  | NOP      :: :: OpNop
  | CONST    :: :: OpConst
  | BINOP    :: :: OpBinOp
  | LOAD     :: :: OpLoad
  | STORE    :: :: OpStore
  | JUMP     :: :: OpJump
  | BNZ      :: :: OpBnz
  | JAL      :: :: OpJAL
  | WRITEEPC  :: :: OpWriteEpc
  | JUMPEPC  :: :: OpJumpEpc
  | ADDRULE  :: :: OpAddRule
  | GETTAG   :: :: OpGetTag
  | PUTTAG   :: :: OpPutTag
  | Op ( i ) :: M :: OpInstr

S :: 's_' ::=  {{com Concrete machine state}}
  | < M , R , K , a  , epc >  :: :: State
    {{tex \langle [[M]],[[R]],[[K]],[[a]],[[epc]] \rangle}}

% Q: Do we need anything like this?
%  | MLab     : regPtr -> regPtr -> Instruction

k :: 'k_' ::= {{com concrete rule}}
  | ( op , tpc , ti , t1 , t2 , t3 | trpc , tr ) :: :: rule {{com a complete rule}}
{{tex
  \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}||@{\;}l@{\;}|@{\;}l@{\;}|}
     \hline
	[[op]] & [[tpc]] & [[ti]] & [[t1]] & [[t2]] & [[t3]] & [[trpc]] & [[tr]] \\
     \hline
     \end{array}
   }}
  | [ ki , ko ]  :: M :: CacheInOut   {{com inputs and outputs parts }}
                  {{tex [ [[ki]] , [[ko]] ] }}
  | rule ( M ) :: :: LoadRule {{com load rule from memory }}

ki {{tex {\kappa_i} }},
kj {{tex {\kappa_j} }} :: 'ki_' ::= {{com  TMU cache input part }}
   | ( op , tpc , ti , t1 , t2 , t3 ) :: :: CacheIn {{tex
     \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|}
	\hline
	   [[op]] & [[tpc]] & [[ti]] & [[t1]] & [[t2]] & [[t3]] \\
	\hline
	\end{array}
      }}
%   |  kdef :: :: CacheOutDft 

ko {{tex \kappa_o }} :: 'ko_' ::= {{com  TMU cache output part }}
   | ( trpc , tr ) :: :: CacheOut {{tex 
      \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
      \hline
	    [[trpc]] & [[tr]] \\
      \hline
	 \end{array}
      }}
%   |  kbot :: :: CacheOutDft 

priv {{tex \pi }} :: 'priv_' ::=   {{com Privilege bit }}
  | upriv                   :: :: PbitOff  {{com user mode }}
  | kpriv                   :: :: PbitOn   {{com kernel mode  }}

Sk :: 'sk_' ::=  {{com Kernel-protection abstract machine state}}
  | < priv , M , R , K , a >  :: :: State
    {{tex \langle [[priv]],[[M]],[[R]],[[K]],[[a]] \rangle}}

formula :: formula_ ::=  
  | judgement   :: :: judgement
  | formula1 quad formula2   :: :: savingspace
  | a1 = a2     :: :: atom_eq {{com atom equality}}
  | i1 = i2     :: :: instr_eq {{com instruction equality}}
  | w1 = w2     :: :: word_eq {{com integer equality}}
  | K1 = K2     :: :: cache_eq {{com cache equality}}
  | k hit K     :: :: hit {{tex [[k]] \in [[K]] }}
  | ki miss K   :: :: miss {{tex [[ki]] \not\in [[K]] }}
  | ki = ki'    :: :: input_eq

terminals :: 'terminals_' ::=
  | -->  :: :: red        {{tex \longrightarrow }}
  | @    :: :: atlabel    {{tex \mathord{@} }}
  | <-   :: :: gets       {{tex \shortleftarrow}}
  | quad :: :: savespace  {{tex \qquad }}
  | +    :: :: plus       {{tex \mathord{+} }}
  | -    :: :: minus      {{tex \mathord{-} }}
  | upriv :: :: upriv     {{tex \text{\sf u} }} 
  | kpriv :: :: kpriv     {{tex \text{\sf k} }} 

defns
ConcreteSmallStep :: '' ::=

  defn 
  S1 --> S2  :: :: cstep :: 'CStep_' by

M(pc) = wi@ti   quad   D(wi) = Nop
(NOP, tpc, ti, _, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Nop_Hit
<M, R, K, pc@tpc, epc> --> <M, R, K, (pc+1)@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = Const n r
(CONST, tpc, ti, _, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: Const_Hit
<M, R, K, pc@tpc, epc> --> <M, R[r <- n@tr ; tpc], K, (pc+1)@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = BinOp o r1 r2 r
R(r1;tpc) = n1@t1   quad   R(r2;tpc) = n2@t2
(BINOP, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: BinOp_Hit
<M, R, K, pc@tpc, epc> --> <M, R[r <- (n1 o n2)@tr; tpc], K, (pc+1)@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = Load r1 r
R(r1;tpc) = n1@t1   quad   M(n1) = w@t2
(LOAD, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: Load_Hit
<M, R, K, pc@tpc, epc> --> <M, R[r <- w@tr; tpc], K, (pc+1)@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = Store r1 r2
R(r1;tpc) = n1@t1   quad   R(r2;tpc) = n2@t2   quad   M(n1) = _@t3
(STORE, tpc, ti, t1, t2, t3 | trpc, tr) hit K
------------------------------------------------------------ :: Store_Hit
<M, R, K, pc@tpc, epc> --> <M[n1 <- n2@tr], R, K, (pc+1)@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = Jump r1
R(r1;tpc) = n1@t1
(JUMP, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Jump_Hit
<M, R, K, pc@tpc, epc> --> <M, R, K, n1@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = Bnz r1 n
R(r1;tpc) = n1@t1   quad   n' = pc + ((n1 = 0)? 1 : n)
(BNZ, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Bnz_Hit
<M, R, K, pc@tpc, epc> --> <M, R, K, n'@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = JAL r1
R(r1;tpc) = n1@t1
(JAL, tpc, ti, t1, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: JAL_Hit
<M, R, K, pc@tpc, epc> --> <M, R[ra <- (pc+1)@tr; tpc], K, n1@trpc, epc>

M(pc) = wi@ti   quad   D(wi) = WriteEpc r
R(r; tpc) = n1@t1
(WRITEEPC, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: WriteEpc
<M, R, K, pc@tpc, epc> --> <M, R, K, (pc+1)@trpc, n1@t1>

M(pc) = wi@ti   quad   D(wi) = JumpEpc
(JUMPEPC, tpc, ti, _, _, _ | _, _) hit K
------------------------------------------------------------ :: JumpEpc
<M, R, K, pc@tpc, epc> --> <M, R, K, epc, epc>

% Could actually take the rule from registers?
% Could actually avoid using the TMU here?
M(pc) = wi@ti   quad   D(wi) = AddRule
(ADDRULE, tpc, ti, _, _, _ | trpc, _) hit K
K' = K U { rule(M) }
------------------------------------------------------------ :: AddRule
<M, R, K, pc@tpc, epc> --> <M, R, K', (pc+1)@trpc, epc>

% Could actually avoid using the TMU here?
M(pc) = wi@ti   quad   D(wi) = GetTag r1 r
R(r1; tpc) = _@t1
(GETTAG, tpc, ti, t1, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: GetTag
<M, R, K, pc@tpc, epc> --> <M, R[r <- t1@tr; tpc], K, (pc+1)@trpc, epc>

% Could actually avoid using the TMU here?
M(pc) = wi@ti   quad   D(wi) = PutTag r1 r2 r
R(r1; tpc) = w@t1   quad   R(r2; tpc) = t@t2
(PUTTAG, tpc, ti, t1, t2, _ | trpc, _) hit K
------------------------------------------------------------ :: PutTag
<M, R, K, pc@tpc, epc> --> <M, R[r <- w@t; tpc], K, (pc+1)@trpc, epc>

% Abusing the _ notation, don't want to write lots of dumb rules
M(pc) = wi@ti   quad   D(wi) = i
(Op(i), tpc, ti, _, _, _) = ki   quad   ki miss K
------------------------------------------------------------ :: Miss
<M, R, K, pc@tpc, epc> --> <M[<-ki], R, K, 0@KERNEL, pc@tpc>

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Kernel protection abstract machine

defns
KAbsSmallStep :: '' ::=

  defn 
  Sk1 --> Sk2  :: :: kastep :: 'KAStep_' by

M(pc; upriv) = wi@ti   quad   D(wi) = Nop
(NOP, tpc, ti, _, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Nop_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R, K, (pc+1)@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = Const n r
(CONST, tpc, ti, _, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: Const_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R[r <- n@tr; upriv], K, (pc+1)@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = BinOp o r1 r2 r
R(r1;upriv) = n1@t1   quad   R(r2;upriv) = n2@t2
(BINOP, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: BinOp_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R[r <- (n1 o n2)@tr; upriv], K, (pc+1)@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = Load r1 r
R(r1;upriv) = n1@t1   quad   M(n1;upriv) = w@t2
(LOAD, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: Load_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R[r <- w@tr; upriv], K, (pc+1)@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = Store r1 r2
R(r1;upriv) = n1@t1   quad   R(r2;upriv) = n2@t2   quad   M(n1;upriv) = _@t3
(STORE, tpc, ti, t1, t2, t3 | trpc, tr) hit K
------------------------------------------------------------ :: Store_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M[n1 <- n2@tr; upriv], R, K, (pc+1)@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = Jump r1
R(r1;upriv) = n1@t1
(JUMP, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Jump_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R, K, n1@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = Bnz r1 n
R(r1;upriv) = n1@t1   quad   n' = pc + ((n1 = 0)? 1 : n)
(BNZ, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Bnz_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R, K, n'@trpc>

M(pc; upriv) = wi@ti   quad   D(wi) = JAL r1
R(r1;upriv) = n1@t1
(JAL, tpc, ti, t1, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: JAL_Hit
<upriv, M, R, K, pc@tpc> --> <upriv, M, R[ra <- (pc+1)@tr; upriv], K, n1@trpc>


% Abusing the _ notation, don't want to write lots of dumb rules
% TODO: this needs to emulate the whole calling convention
M(pc; upriv) = wi@ti   quad   D(wi) = i
(Op(i), tpc, ti, _, _, _) = ki   quad   ki miss K
------------------------------------------------------------ :: Miss
<upriv, M, R, K, pc@tpc> --> <kpriv, M[<-ki], R, K, X@KERNEL>


M(pc; kpriv) = wi@_   quad   D(wi) = Nop
------------------------------------------------------------ :: Nop_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R, K, (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = Const n r
------------------------------------------------------------ :: Const_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R[r <- n@KERNEL; kpriv], K, (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = BinOp o r1 r2 r
R(r1;kpriv) = n1@_   quad   R(r2;kpriv) = n2@_
------------------------------------------------------------ :: BinOp_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R[r <- (n1 o n2)@KERNEL; kpriv], K, (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = Load r1 r
R(r1;kpriv) = n1@_   quad   M(n1; kpriv) = w@_
------------------------------------------------------------ :: Load_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R[r <- w@KERNEL; kpriv], K, (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = Store r1 r2
R(r1;kpriv) = n1@_   quad   R(r2;kpriv) = n2@_   quad   M(n1; kpriv) = _@_
------------------------------------------------------------ :: Store_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M[n1 <- n2@KERNEL; kpriv], R, K, (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = Jump r1
R(r1;kpriv) = n1@_
------------------------------------------------------------ :: Jump_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R, K, n1@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = Bnz r1 n
R(r1;kpriv) = n1@_   quad   n' = pc + ((n1 = 0)? 1 : n)
------------------------------------------------------------ :: Bnz_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R, K, n'@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = JAL r1
R(r1;kpriv) = n1@_
------------------------------------------------------------ :: JAL_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R[ra <- (pc+1)@KERNEL; kpriv], K, n1@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = AddRule
K' = K U { rule(M) }
------------------------------------------------------------ :: AddRule_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R, K', (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = GetTag r1 r
R(r1; kpriv) = _@t1
------------------------------------------------------------ :: GetTag_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R[r <- t1@KERNEL; kpriv], K, (pc+1)@KERNEL>

M(pc; kpriv) = wi@_   quad   D(wi) = PutTag r1 r2 r
R(r1; kpriv) = w@_   quad   R(r2; kpriv) = t@_
------------------------------------------------------------ :: PutTag_K
<kpriv, M, R, K, pc@KERNEL> --> <kpriv, M, R[r <- w@t; kpriv], K, (pc+1)@KERNEL>

% TODO: we currently have way to go from kpriv to upriv! How to fix this?
