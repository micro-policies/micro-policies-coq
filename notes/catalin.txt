TODO: can all these type classes be refactored to exploit sharing?

[2014-06-05] All DONE

symbolic:
- 3 types for tags: registers, pc, memory

cfi:
- can we make the symbolic machine call the fault handler before
  doing a system call
- we seemed to need the old getMVec relation to define the simulation
  relation [not sure any more]
  + one way would be to add another parameter to step,
    and then just project things out to get the current step
    and getMVec
  + but maybe we don't need this at all, we can look at the tag
    on the pc and the pc itself

[2014-05-22] memory safety -- some still TODO
abstract.v
- it would be nicer to have blocks and allocation be abstract

TODO: look at Maxime's code -- started this a while back

memory safety property
- backwards refinement
  + forwards seems hard (see below)
  + still questions about the "right" abstract machine
- pointers are unforgeable
  + i.e. one can only obtain a pointer to a certain block by
    allocation or by being passed one such pointer
  + if a pointer is allocated and then discarded (without it first
    being freed) then the block will be inaccessible forever
- this is also a (more dynamic) form of isolation we could try to
  capture explicitly
  + a piece of code can only access blocks to which it has pointers

how do we deal with allocation?
- at the abstract level
  - either non-deterministic
    + we lose forwards refinement
  - or fixed deterministic but abstract allocator
    (as David did in the POPL 2014 paper)

how do we deal with allocation failures?
- if abstract allocation always succeeds and
  concrete one can fail then we lose forwards refinement

how do we deal with the fact that words are finite?
- do we use multiprecision integers to represent block ids?
- this is what the abstract machine does
- this ensure that block numbers are not repeated,
  but can be very inneficient
  + unless we have a smart way of representing small
    multiprecision integers using normal integers

[2014-04-18]
Reading about SFI/Component Sandboxing
http://homes.cs.washington.edu/~tom/pubs/sfi.html
- low overhead communication with untrusted extensions/modules/components
  (basically the Google NaCl and RockSalt scenario)
  + doing this via system calls between different processes
    would be too expensive for situations with very frequent calls
- the address ranges where components reside are _contigous_
  + which means this cries for some kind of HW optimizations
    we don't currently have
- doing it in software takes 4% overhead without stopping reads
  and ~20% for "full protection"
  + with the PUMP we'll probably have more than that,
    which is a bit silly
  + on the other hand we don't have to instrument binaries,
    other than breaking them up in components
  + larger overhead for also sandboxing reads/loads
    + Heartbleed shows that sandboxing reads is important!
- trusted components don't need to be sandboxed,
  so they don't incur any overhead

Antal's prototype
- should also sandbox reads/loads -- seems trivial
- notation improvement: e.g. C |- pc ~ pc+1,
  or just define a function Comp(C,pc) and assert that:
  Comp(C,pc) = Comp(C,pc+1) = (A,J,S)
- while components start out as continous sets, further sandboxing
  parts of them will lead to non-contiguity
  + so A, J, and S are trully sets of addresses
  + A could still be represented as a set of ranges
- isolate is morally a micro call, not an instruction
  + components are not really nested
    - although Antal's comment claims otherwise
      (hierarchically-created mutually-distrustful components)
      + isn't it enough to have one top-level component
        that creates everything and then shuts down?
        that's how seL4 and other component systems work.
  + the parent component gets very little control; it basically loses
    a range of memory, without gaining much
    - not sure this is right
  + other possible system calls:
    - grant permission: grants J/S/L access to another component to an
      address of the current component
- jump vs jal
  - current assumption: jal for calls and jump for returns
- how do returns work?
  + one solution would be to make the return address a capability
    to call back ... although this might need to be further constrained
    + linear capability?
- preserving registers between calls seems a bit strange
  + it might cause confusion and leaks

[2014-03-04]
(* CH: Is this declarative semantics still useful?
   It now looks so similar to the executable variant. *)
- It still seems used all over the place

TODO:
- TODOs in the code: factor out maps
- consistent naming conventions (with Maxime)
  + extraction might impact this big time
- write down lowest level machine for memory safety
  + help paralelize this task (Antal? Arthur?)

[2014-01-19]
DONE:
- Removed k0 and k1
- don't care + copy through masks
- initial state (informally)
- discussed about final theorem
- code cleanup and review

[2014-01-16] telecon
- Memory Safety -- (re)focus on this for now
- Stack Protection -- try at least to sketch it out; working out the
  memory safety concrete machine might help a bit with that
- Kernel Protection -- a stock architecture anyway already offers
  that, so why not just using it for now, instead of trying to replace
  old HW with SW + new HW
- stick with state refinement for now
- Andrew: more high level (try not to so something that's super
  dependent on the ISA we're defining), tempest, register conventions,
  etc.

[2014-01-15]
Discussion about "don't cares" and "copy through"-s
Q: Since we anyway add privileged instructions, can't we give them the
semantics we need (e.g. not consulting the TMU) so that we don't need
wildcards at all?
- this would bake more of the kernel protection et al into the HW,
  so it would be less general

Potential solutions (after email exchange with Andre, and some thinking):

We should (in any case) get rid of TAny and TNone (they are uselessly
poluting the tag space, and complicating our invariants .. TAny at least).

Instead of this we could either (A) changing the type of the MVector
(more powerful, especially in conjunction with copy-through R-values,
but harder to reason about), or (B) adding a don't care vector and use
it for the privileged instructions (more in sync to what the real HW
does). Basically, the don't care vector would be another part of the
top-level (potentially compound) micro-policy (together with the fault
handler code and the ground rules).

For (B), we would change the current ground rules for kernel
protection as follows:
- for non-privileged instructions, we would turn TAny into TKernel,
  and TNone into uses of the don't care vector
- for privileged instructions, we would turn both TAny and TNone into
  uses of the don't care vector

The risk with adding extra privileged instructions only so that we can
give them different don't care vectors is that we want to support an
arbitrary number of micro-policies, and we don't know in advance if
the instructions we have are enough for that. We should at least be
able to do the following actions without faulting:
- spill/restore user registers to/from kernel memory (GetTag, SetTag,
  Load, Store seem enough for that)
- return to user mode (JumpEpc does that)
- do user stack protection (might need GetTagM and SetTagM?)
We were anyway already going in this direction.

A discussion we should still have at some point is whether the TMU HW
mechanism is already fixed, or whether we can still contribute to it's
design and evolution. My hope so far was that things could still be
further generalized.

---------

Q for Maxime: Just curious, why the change from Z to nat for words?
  is it just for simplicity or is there anything deeper behind?

common.v: I don't understand reg_spec, regP, reg_ra_spec, reg_raP 
- Maxime says it tries to replicate SSReflect-style proofs

common.v: exec ... that's just reflexive transitive closure
- there should be a definition for that in the Coq library

abstract.v: why not move "w # instr" notation to common.v?
- why not use it in concrete.v too?

abstract.v:
             forall (MDPC : modes pc = User),
- this is just an invariant, not the way we will distinguish between
  user and kernel mode
- however, in a world _without_ kernel entry points we might really
  use this, and not tag the pc, to obtain kernel protection ... right?

concrete.v:
- why do we protect epc by making it not a part of the register frame,
  while we protect k0 and k1 while still keeping them in the register frame
  + epc can't be an user-accessible register, but both mechanisms
    protect registers from user access don't they?
  + Q: Wouldn't it make more sense to move k0 and k1 out of the user
    register frame, into a separate kernel register frame
  + Q: Wouldn't it make sense, in first instance at least, to consider
    this kernel register frame large enough for all practical
    purposes, or even infinite
  + Q: Alternatively, wouldn't it make sense to make epc just another
    kernel-only register?
- A: We need JumpEPC instruction that can't fault in order to return
  from the fault handler
  + alternatively, we need "Copy through R-values", so that we can write
    strong enough ground rules
- there is also the question if the kernel (fault handler) ever needs to fault
  + but I think in any case it will need to save the epc beforehand

refinement.v: proof
- naming completely fucked up:
  + abstract and concrete things named the same way
    (add a and c prefixes everywhere; now only sometimes used)


2014-01-13 Verif Telecon

Papers for the next 9 months (SAFE)

2 - 2.5 verification papers to write in 9 months
- Stock pico project only weakly related to SAFE
  + still BCP finds it really interesting
  + could be multiple papers
  + could try to bring evaluation to verification
  + how realistic do we want our machines to be?
    maybe not enough resources for this
  + use experiments to guide what's more interesting to verify?
    - BCP: do that just for IFC; very important for SAFE!
      + might find something to do there on verification?
- POPL community doesn't care about performance
  + the interest is about the breath of the things we can support

software sandboxes
- region-based memory protection (might be more efficient)
  be fine grained when it works (efficient) and coarse grained otherwise

POPL paper of low-level micro-policies
- time is already not infinite
- investigate some micro-policies

Formalizing SAFE instruction set
- BCP finds the instruction set cool
- could be a paper
- maybe even without formalization
- description and justification of all the pieces
- plus some experimental/empirical justification
- Ask questions like "does it need to be this way?"
  + authority, gates, linearity

Non-forking case:
- result won't be a POPL paper, but more like an ASPLOS paper

We could each choose a side of a fork

Tempest: static + dynamic types?
