* Goal of these notes
- Trying to work out some of the details of a very different "label
  model" for the pico machine; one for memory protection
- This is inspired by Udit and Andre's experiments for their ASPLOS paper;
  and could maybe at some point help formalize what they are doing there
  - We started with that (see notes/2013-05-memory-protection) but
    eventually we dropped the memory reclaiming via Free system call
  - In that setting we could prevent double/invalid frees and
    loads+stores after free
- This work would be orthogonal to the IFC "label model", and
  composing this with the IFC label model would be a different task
  that's not discussed here, and not necessary to get started

** Here are Udit's slides that are relevant here:
(taken from talks/internal/20130422_F2F_Penn/tmu_asplos2014.pdf)
- Spatial/Temporal Safety:
  - On each allocation, create a new ID (sequentially)
  - Assign the same ID to the pointer, and,
  - All the memory locations that are allocated
  - Upon de-allocation, change the ID on all the freed memory
    locations to some constant
- Spatial/Temporal Safey LM
  - Rule Computation:
    - Upon miss, install a rule that says that the ID on the pointer and
      memory location should be the one that missed
    - Put that rule into the TMU

* [Extremely] related work

J. A. Clause, I. Doudalis, A. Orso, and M. Prvulovic. Effective memory
protection using dynamic tainting. In 22nd IEEE/ACM International
Conference on Automated Software Engineering (ASE). 2007.
http://www.cc.gatech.edu/~orso/papers/clause.doudalis.orso.prvulovic.pdf

* How does this work / how would this look like
** At the abstract level
(see main.pdf for a precise account of this)

The abstract machine for this "label model" would extend the
current pico abstract machine as follows:
- (a variant of) Swiss cheese memory model
  - a pointer is a pair of a frame (with base and bound) and an offset
  - the offset doesn't need to be inside bounds, and it can be negative
- pointers are distinguished from plain integers
  - 2 different kinds of values: pointers and integers
  - pointers are unforgeable!
- non-deterministic(???) allocation primitive returning fresh pointers
- arbitrary (unchecked) pointer arithmetic is allowed
  - and it could happen with the normal arithmetic operations;
    i.e. adding a pointer to an integer returns a new pointer
    - seems that still requires a different opcode, so just 
      called this operation OffP (relative offsetting)
      - APT: Why does this require an extra opcode? Can't op be "polymorphic"?
      - CH: We can write it as "BinOp OffP" or even "BinOp +" if you
            like it more, but both the abstract semantics and the
            quasi-abstract semantics + rules have to treat this case
            very differently from the other binops -- so not
            parametrically polymorphic but ad-hoc polymorphic
            (overloaded). Is your point that since at the concrete
            level this will be implemented as an BinOp + (and all the
            magic will happen in the TMU), it should be called BinOp +
            even at the abstract levels? I would sympathize with that :)
      - CH: Yes, shouldn't add instrs unless absolutely necessary!
  - pointers to the same frame can be subtracted (and thus compared)
    - with the SubP instruction; same discussion as for OffP applies
      here too
- pointers can get out of bounds in either direction
  - offsets can be negative
- accessing out of bounds pointers is an error and stops the machine
- out of bounds pointers can become in bounds again,
  in which case accessing them should work fine
- out of bounds pointers can't all of a sudden start pointing to a
  different frame (quite obvious from the way we define things
  in the abstract machine)
- pointers can't be casted to integers and integers can't be casted to
  pointers (obvious from the definition)

** At the quasi-abstract (tags + system calls + rules) level
(see main.pdf for a more abstract variant of this in which the rules
 and system calls are not extracted out of the semantics)

*** Tags

- We have three kinds of tags:
  - one for values (V)
  - another one for currently allocated memory locations (M)
  - another one for free memory locations (F)
    - we can assume that the whole memory starts out tagged F

T :=  V(Ty) | M(n,Ty) | F

- Both values and the payload of memory locations have a type (Ty)
  - the type of pointers includes the value of the base (n)

Ty := I | P(n)

*** System calls
- Alloc, OffP, and SubP are system calls
- Q: do we have any way of implementing system calls that keep state
  between invocations on the current concrete machine?
- assuming we find one, then here is the description of these calls
**** Alloc
- pops a number j off the stack (fails otherwise)
- allocates a new frame of size j, obtaining a new int pointer n
  - either in the code, in which case it needs to keep track of
    previously allocated and freed frames (more state)
  - or by executing a primitive privileged instruction of the
    concrete machine
- fills the new frame n...n+j-1 with zeroes tagged M(n,I)
- pushes the atom n@P(n) to the stack and returns to user code
  - this looks like we're lifting the value of n to the tag,
    but then we're (intentionally) not keeping them in sync
- CH: we don't use non-repeatable nonces (a counter) here, and we can
  only get away with it because we're in a garbage collected world;
  this wouldn't work in the presence of manual deallocation
**** Offp
- expects n@P(c) and m@I on top of the stack
- produces (n+m)@P(c) as the result without any additional checks
  - in particular there is no check that n+m is in bounds wrt c
- CH: this doesn't need to be a system call, but a plain
      addition; see discussion above

*** Rules
**** Obsolete variant
		Allow				Result
NOP		TRUE				-
OUT		TAG1=V(I)			TAG1
BINOP		TAG1=V(I) AND TAG2=V(I)		V(I)
PUSH		TRUE				V(I)
JUMP		TAG1=V(I)			-
BNZ		TAG1=V(I)			-
CALL		TAG1=V(I)			V(I)
RET		TAG2=V(I)			TAG1
LOAD		TAG1=V(P(n)) AND TAG2=M(n,T2)	V(T2)
STORE		TAG1=V(P(n)) AND TAG2=V(T2)
		             AND TAG3=M(n,T3)	M(n,T2)

- the pc tag is always @V(I), so I didn't write it in the table

- things like n and T2,T3 above are unification variables
  - I think this looks kind of cool, but if this is a problem to
    implement we can change to explicit testers (IS_V, IS_VI, IS_VP,
    IS_M) and deconstructors (GET_VPB, GET_MB, GET_MT)]

**** Better variant

		Allow				Result
NOP		TRUE				-
OUT		IS_VI(TAG1)			TAG1
BINOP		IS_VI(TAG1) AND IS_VI(TAG2)	V(I)
PUSH		TRUE				V(I)
JUMP		IS_VI(TAG1)			-
BNZ		IS_VI(TAG1)			-
CALL		IS_VI(TAG1)			V(I)
RET		IS_VI(TAG2)			TAG1
LOAD		IS_VP(TAG1) AND IS_M(TAG2)
		AND GET_VPB(TAG1)=GET_MB(TAG2)	V(GET_MT(TAG2))
STORE		IS_VP(TAG1) AND IS_V(TAG2)
		AND IS_M(TAG3)
		AND GET_VPB(TAG1)=GET_MB(TAG3)	M(GET_VPB(TAG1),GET_MT(TAG2))

- if OffP and SubP were instructions then they would have these rules

OFFP		IS_VP(TAG1) AND IS_VI(TAG2)	V(P(GET_VPB(TAG1)))
SUBP		IS_VP(TAG1) AND IS_VP(TAG2)
		AND GET_VPB(TAG1)=GET_VPB(TAG2)	V(P(GET_VPB(TAG1)))

- for this better variant the syntax of tag and boolean expressions is as follows:

TE := TAG1 | TAG2 | TAG3 | TAGPC | V(TYPE) | M(NE,TYPE)

BE := TRUE | IS_V(TE) | IS_VI(TE) | IS_VP(TE) | IS_M(TE) |
      NE1 = NE2 | BE1 AND BE2 | BE1 OR BE2

TYPE := I | P(NE) | GET_MT(TE)

NE := GET_MB(TE) | GET_VPB(TE)

- the forms TAGPC and BE1 OR BE2 are not used anywhere (OR would be
  used if we had overloading; in which case we would probably also
  need IF-THEN-ELSE in TE)

*** Previous discussion (rather obsolete now)
  - on malloc labeling contents and pointer the same
  - on each load and store compare ptr with cell
  - Q: what if pointers are stored in memory??
       what would that label mean?
  - A: pair of tags in memory
    - every memory cell has 2 tags:
      pointer tag (allocator returns such pointers,
                   pointer arithmetic preserves it)
      + frame tag (allocator instantiates memory with this)
    - things not in memory only one tag
  - BCP/APT: We should talk to Udit about what he has in mind here! 
  - APT: I asked Udit about that this evening. He hadn't 
    thought about the problem of having pointers in memory.

** At the concrete level
*** We need a way to do system calls
- Instruction that changes between user mode and kernel mode
- The first argument on the stack identifies the system call?
  (e.g. 0 = Alloc ... is Alloc the only one?)
*** We need a ReTag privileged instruction
Will be used by Alloc system call to tag the pointer it returns
*** We need a way to allocate things
- but at the concrete level the only property we need for the
  allocator is freshness, not protection
- as in C, the code can walk the whole memory, both allocated and
  not-yet-allocated
- this allocator can:
  - either be part of the concrete machine definition
    (i.e. implemented by an even lower level but abstracted away here)
  - or be implemented in software
  - BCP/APT: Not clear that the former option makes sense
  - CH: why not?

* Pending questions/discussions/thinking:
** Concrete allocator: kernel vs user space
- how does writing an allocator interact with the 2 different address
  spaces idea; will we need 2 different allocators, one for
  "privileged memory" and another one for "user memory"?
  - seems that the built-in naive memory protection gets in the way of
    implementing this more interesting memory protection
  - BCP/APT: Kernel memory stays the same; user memory becomes swiss cheese
    (APT: maybe...)
  - CH: but for other label models (e.g. the IFC one) we will
    eventually need to allocate the tags; so the "privileged memory"
    will also need allocation
  - CH: anyway, for now I'm going to completely ignore that there is a
    kernel address space that might also need an allocator

** Expose per-frame tags in the high-level abstract machine if exposing the TMU
- With the pair tagging mechanism for memory we are simulating additional
  per-frame tags
- Yes, but the low level machines have no frames, so we need to
  simulate it
- Q: Wouldn't it make sense to expose per-frame tags in the high-level
  abstract machine if exposing the TMU?
- That would be great, it might save us pair encodings later on

* Answered questions
** Do we really need to tag memory differently than ordinary atoms?
- Q: To support this simple model, do we really need to tag memory
  differently than ordinary atoms?
- Isn't it enough to associate base
  and bounds to all pointers, and propagate and check that
  information with the TMU?
  - need to be careful here, the TMU can only look at the tags of
    operands, not at their values
  - the TMU won't have all the information it needs to decide if
    a Load or a Store should be allowed. It won't have the actual
    value of the pointer, only the base and the bounds!
  - lifting the value of the pointer to its tag means that the
    TMU will be performing the same operations at the ALU
    - except that it can't do that for offsetting, because integers
      are not lifted this way
    - also lifting integers would be equivalent to passing all values
      into the TMU, but then its functioning as a cache will be very
      limited
- A (short): This won't work!
  - Is this the reason why the SAFE machine has a separate pointer
    unit?

** Do we even need to distinguish pointers from integers?
Q: In this simpler model, at the quasi-quasi-abstract level, do we
even need to distinguish pointers from integers?
- A: Yes, see below.
- A2: Yes, otherwise garbage collection won't work.

- Q: In this simpler model, at the quasi-quasi-abstract level, do we
  prevent a pointer from moving to another valid frame and then
  changing it?
  - we turn P(c) into P(n) as proposed by Andrew; so yes, we still
    need to distinguish pointers from integers
