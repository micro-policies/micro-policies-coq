
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Metavariable conventions

% TODO: epc is probably more special and will need to be moved out of here
metavar r, ra, epc ::= {{com register number (e.g. 0..31)}}

metavar D ::= {{com decoding (partial function)}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

grammar

o {{tex \mathord{\circ} }} :: 'o_' ::= {{com binary ops}}
  | + :: :: OPlus
  | - :: :: OMinus

M :: 'M_' ::= {{com memory}}
  | M [ w <- a ] :: M :: mem_update {{com memory update}}
  | M [ <- ki ]  :: M :: mem_rule_store {{com store rule inputs somewhere in KERNEL memory}}

R :: 'R_' ::= {{com register file}}
  | R [ r <- a ] :: M :: reg_update {{com register update}}

K :: 'K_' ::= {{com rule cache}}
  | K U { k } :: M :: cache_add {{tex [[K]] \cup \{ [[k]] \} }}{{com adding rule [[k]] to cache [[K]]}}

w, wi {{tex w_i}}, n, pc, sp, t, tpc {{tex t_\mathit{pc} }}, ti {{tex t_i}}, tr {{tex t_r}}, trpc {{tex t_\mathit{rpc} }} :: 'w_' ::= {{com Words (Integers)}}
  | 0          :: :: Zzero
  | 1          :: :: Zone
  | n1 o n2    :: :: ZBinOp  {{com binop on ints returns int}}
  | KERNEL     :: :: TKernel {{com kernel tag}}
  | ANY        :: :: TAny {{com wildcard tag (used in ground rules) }}
  | ( n1 = n2 ) ? n3 : n4  :: M :: ZIf
  | _          :: M :: Tirrev {{tex \_}}{{com irrelevant tag}}
  | ( w )      :: S :: ZParen

a, b  :: 'a_' ::= {{com Atoms}}
  | w @ t    :: :: Atom {{com atom = tagged word }}
  | M ( w )  :: M :: mem_lookup  {{com memory lookup (partial function)}}
  | R ( r )  :: M :: reg_lookup  {{com register lookup (total function)}}
  | ( a )    :: S :: AParen

i :: 'i_' ::=  {{com Instructions}}
  | Const n r        :: :: IConst  {{com load constant}}
  | BinOp o r1 r2 r  :: :: IBinOp  {{com binary arithmetic operation}}
  | Load r1 r        :: :: ILoad   {{com memory load (from the address in [[r1]] to [[r2]])}}
  | Store r1 r2      :: :: IStore  {{com memory store (word in [[r2]] at address in [[r1]])}}
  | Jump r           :: :: IJump   {{com unconditional jump (absolute)}}
  | Bnz r n          :: :: IBnz    {{com conditional branch non-zero (relative)}}
  | Call r           :: :: ICall   {{com function call}}
  | Return           :: :: IReturn {{com function return}}
  | JAL r1           :: :: IJAL    {{com jump and link (call subroutine)}}
  | AddRule          :: :: IAddRule {{com add rule to TMU cache (privileged)}}
  | GetTag r1 r      :: :: IGetTag  {{com make the tag of [[r1]] the payload of [[r]] (privileged)}}
  | PutTag r1 r2 r   :: :: IPutTag  {{com set [[r]] to atom with the same payload as [[r1]]
                                          and the payload of [[r2]] as tag (privileged)}}
  | KJEPC            :: :: IKJEPC {{com jump from kernel (privileged)}}
  | D ( w )          :: M :: IDecode  {{com decoding (partial function)}}

op :: 'op_' ::=  {{com Opcodes}}
  | const    :: :: OpConst
  | binop    :: :: OpBinOp
  | load     :: :: OpLoad
  | store    :: :: OpStore
  | jump     :: :: OpJump
  | bnz      :: :: OpBnz
  | call     :: :: OpCall
  | return   :: :: OpReturn
  | jal      :: :: OpJAL
  | addrule  :: :: OpAddRule
  | gettag   :: :: OpGetTag
  | puttag   :: :: OpPutTag
  | Op ( i ) :: M :: OpInstr

S :: 's_' ::=  {{com Machine state}}
  | < M , R , K , a , sp >  :: :: State
    {{tex \langle [[M]],[[R]],[[K]],[[a]],[[sp]] \rangle}}

% Q: Do we need anything like this?
%  | MLab     : regPtr -> regPtr -> Instruction
%  | PcLab    : regPtr -> Instruction

k :: 'k_' ::= {{com concrete rule}}
  | ( op , tpc , ti , t1 , t2 , t3 | trpc , tr ) :: :: rule {{com a complete rule}}
{{tex
  \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}||@{\;}l@{\;}|@{\;}l@{\;}|}
     \hline
	[[op]] & [[tpc]] & [[ti]] & [[t1]] & [[t2]] & [[t3]] & [[trpc]] & [[tr]] \\
     \hline
     \end{array}
   }}
  | [ ki , ko ]  :: M :: CacheInOut   {{com inputs and outputs parts }}
                  {{tex [ [[ki]] , [[ko]] ] }}
  | rule ( M ) :: :: LoadRule {{com load rule from memory }}

ki {{tex {\kappa_i} }},
kj {{tex {\kappa_j} }} :: 'ki_' ::= {{com  TMU cache input part }}
   | ( op , tpc , ti , t1 , t2 , t3 ) :: :: CacheIn {{tex
     \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|@{\;}l@{\;}|}
	\hline
	   [[op]] & [[tpc]] & [[ti]] & [[t1]] & [[t2]] & [[t3]] \\
	\hline
	\end{array}
      }}
   |  kdef :: :: CacheOutDft 

ko {{tex \kappa_o }} :: 'ko_' ::= {{com  TMU cache output part }}
   | ( trpc , tr ) :: :: CacheOut {{tex 
      \begin{array}{|@{\;}l@{\;}|@{\;}l@{\;}|}
      \hline
	    [[trpc]] & [[tr]] \\
      \hline
	 \end{array}
      }}
   |  kbot :: :: CacheOutDft 

formula :: formula_ ::=  
  | judgement   :: :: judgement
  | formula1 quad formula2   :: :: savingspace
  | a1 = a2     :: :: atom_eq {{com atom equality}}
  | i1 = i2     :: :: instr_eq {{com instruction equality}}
  | w1 = w2     :: :: word_eq {{com integer equality}}
  | K1 = K2     :: :: cache_eq {{com cache equality}}
  | k hit K     :: :: hit {{tex [[k]] \in [[K]] }}
  | ki miss K   :: :: miss {{tex [[ki]] \not\in [[K]] }}
  | ki = ki'    :: :: input_eq

terminals :: 'terminals_' ::=
  | -->  :: :: red        {{tex \longrightarrow }}
  | @    :: :: atlabel    {{tex \mathord{@} }}
  | <-   :: :: gets       {{tex \shortleftarrow}}
  | quad :: :: savespace  {{tex \qquad }}
  | +    :: :: plus       {{tex \mathord{+} }}
  | -    :: :: minus      {{tex \mathord{-} }}

defns
SmallStepEval :: '' ::=

  defn 
  S1 --> S2  :: :: step :: 'Step_' by

M(pc) = wi@ti   quad   D(wi) = Const n r
(const, tpc, ti, _, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: Const_Hit
<M, R, K, pc@tpc, sp> --> <M, R[r <- n@tr], K, (pc+1)@trpc, sp>

M(pc) = wi@ti   quad   D(wi) = BinOp o r1 r2 r
R(r1) = n1@t1   quad   R(r2) = n2@t2
(binop, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: BinOp_Hit
<M, R, K, pc@tpc, sp> --> <M, R[r <- (n1 o n2)@tr], K, (pc+1)@trpc, sp>

M(pc) = wi@ti   quad   D(wi) = Load r1 r
R(r1) = n1@t1   quad   M(n1) = w@t2
(load, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: Load_Hit
<M, R, K, pc@tpc, sp> --> <M, R[r <- w@tr], K, (pc+1)@trpc, sp>

M(pc) = wi@ti   quad   D(wi) = Store r1 r2
R(r1) = n1@t1   quad   R(r2) = n2@t2   quad   M(n1) = _@t3
(store, tpc, ti, t1, t2, t3 | trpc, tr) hit K
------------------------------------------------------------ :: Store_Hit
<M, R, K, pc@tpc, sp> --> <M[n1 <- n2@tr], R, K, (pc+1)@trpc, sp>

M(pc) = wi@ti   quad   D(wi) = Jump r1
R(r1) = n1@t1
(jump, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Jump_Hit
<M, R, K, pc@tpc, sp> --> <M, R, K, n1@trpc, sp>

M(pc) = wi@ti   quad   D(wi) = Bnz r1 n
R(r1) = n1@t1   quad   n' = pc + ((n1 = 0)? 1 : n)
(bnz, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Bnz_Hit
<M, R, K, pc@tpc, sp> --> <M, R, K, n'@trpc, sp>

M(pc) = wi@ti   quad   D(wi) = Call r1
R(r1) = n@t1   quad   M(sp) = _@t2
(call, tpc, ti, t1, t2, _ | trpc, tr) hit K
------------------------------------------------------------ :: Call_Hit
<M, R, K, pc@tpc, sp> --> <M[sp <- (pc+1)@tr], R, K, n@trpc, sp-1>

M(pc) = wi@ti   quad   D(wi) = Return
M(sp+1) = n@t1
(return, tpc, ti, t1, _, _ | trpc, _) hit K
------------------------------------------------------------ :: Return_Hit
<M, R, K, pc@tpc, sp> --> <M, R, K, n@trpc, sp+1>

% Could actually take the rule from registers?
% Could actually avoid using the TMU here?
M(pc) = wi@ti   quad   D(wi) = AddRule
(addrule, tpc, ti, _, _, _ | trpc, _) hit K
K' = K U { rule(M) }
------------------------------------------------------------ :: AddRule_Hit
<M, R, K, pc@tpc, sp> --> <M, R, K', (pc+1)@trpc, sp>

% Could actually avoid using the TMU here?
M(pc) = wi@ti   quad   D(wi) = GetTag r1 r
R(r1) = _@t1
(gettag, tpc, ti, t1, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: GetTag_Hit
<M, R, K, pc@tpc, sp> --> <M, R[r <- t1@tr], K, (pc+1)@trpc, sp>

% Could actually avoid using the TMU here?
M(pc) = wi@ti   quad   D(wi) = PutTag r1 r2 r
R(r1) = w@t1   quad   R(r2) = t@t2
(puttag, tpc, ti, t1, t2, _ | trpc, _) hit K
------------------------------------------------------------ :: PutTag_Hit
<M, R, K, pc@tpc, sp> --> <M, R[r <- w@t], K, (pc+1)@trpc, sp>

% Abusing the _ notation, don't want to write lots of dumb rules
M(pc) = wi@ti   quad   D(wi) = i
(Op(i), tpc, ti, _, _, _) = ki   quad   ki miss K
------------------------------------------------------------ :: Miss
<M, R, K, pc@tpc, sp> --> <M[<-ki][sp <- pc@tpc], R, K, 0@KERNEL, sp-1>

M(pc) = wi@ti   quad   D(wi) = JAL r1
R(r1) = n1@t1
(jal, tpc, ti, t1, _, _ | trpc, tr) hit K
------------------------------------------------------------ :: JAL_Hit
<M, R, K, pc@tpc, sp> --> <M, R[ra <- (pc+1)@tr], K, n1@trpc, sp>

% Abusing the _ notation, don't want to write lots of dumb rules
M(pc) = wi@ti   quad   D(wi) = i
(Op(i), tpc, ti, _, _, _) = ki   quad   ki miss K
------------------------------------------------------------ :: MissNew
<M, R, K, pc@tpc, sp> --> <M[<-ki], R[epc <- pc@tpc], K, 0@KERNEL, sp>

M(pc) = wi@ti   quad   D(wi) = KJEPC
R(epc) = n1@t1  quad   tpc = KERNEL
------------------------------------------------------------ :: KJEPC
<M, R, K, pc@tpc, sp> --> <M, R, K, n1@t1, sp>
